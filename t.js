/******************************************************************
 * FACEBOOK MULTI STREAM MANAGER
 * Author: You
 * Description:
 * - Fetch streams from API
 * - Create Facebook Live
 * - Wait 15 seconds before FFmpeg
 * - Start FFmpeg
 * - Wait for ALL streams to be running
 * - Then fetch DASH URLs (MPD)
 * - Send full Telegram reports
 * - Send preview URLs to GitHub Gist
 * - Handle exceptions with delay
 ******************************************************************/

// ================== IMPORTS ==================
import { spawn } from "child_process";
import fs from "fs";

// ================== CONFIG ==================
const CONFIG = {
  apiUrl: "https://ani-box-nine.vercel.app/api/grok-chat",

  pollInterval: 60_000,          // Check every minute for API changes
  restartDelay: 2 * 60_000,      // ‚è≥ Wait 2 minutes after any exception
  reportInterval: 5 * 60_000,    // üìä Telegram report every 5 minutes
  healthCheckInterval: 30_000,   // Health check every 30 seconds
  maxRetries: 3,                 // Max retries per stream before full restart
  preStartDelay: 15_000,         // Wait 15 seconds before starting FFmpeg
  ffmpegStartDelay: 2_000,       // Delay between FFmpeg starts (2 seconds)

  telegram: {
    botToken: "7971806903:AAHwpdNzkk6ClL3O17JVxZnp5e9uI66L9WE",
    chatId: "-1002181683719",
  },

  github: {
    gistId: "", // Will be created automatically if empty
    token: "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", // Replace with your GitHub token
    filename: "facebook-live-streams.md"
  }
};

// ================== GLOBAL STATE ==================
let allItems = new Map();        // All streams
let activeStreams = new Map();   // FFmpeg processes with metadata
let isRestarting = false;
let startTime = Date.now();
let apiDataHash = "";           // Store hash of API data to detect changes
let streamRetries = new Map();  // Track retry counts per stream

// ================== LOGGER ==================
class Logger {
  static log(level, msg) {
    const line = `[${new Date().toISOString()}] [${level}] ${msg}`;
    console.log(line);
    fs.appendFileSync("logs.txt", line + "\n");
  }
  static info(m) { this.log("INFO", m); }
  static warn(m) { this.log("WARN", m); }
  static error(m) { this.log("ERROR", m); }
  static success(m) { this.log("SUCCESS", m); }
}

// ================== GITHUB GIST MANAGER ==================
class GithubGistManager {
  // Create or update GitHub Gist with stream URLs
  static async updateGist(streamsData) {
    try {
      // Prepare markdown content
      let markdown = `# Facebook Live Streams\n\n`;
      markdown += `**Last Updated:** ${new Date().toISOString()}\n\n`;
      markdown += `## Active Streams\n\n`;
      
      streamsData.forEach((stream, index) => {
        markdown += `### ${index + 1}. ${stream.name}\n`;
        markdown += `- **DASH URL (MPD):** ${stream.dash || "Not available"}\n`;
        markdown += `- **Facebook Live ID:** ${stream.streamId || "N/A"}\n`;
        markdown += `- **Source:** ${stream.source}\n`;
        markdown += `- **Status:** ${stream.status || "Active"}\n\n`;
      });
      
      markdown += `---\n*Auto-generated by Facebook Multi Stream Manager*\n`;
      
      const gistData = {
        description: `Facebook Live Streams - ${new Date().toISOString()}`,
        public: true,
        files: {
          [CONFIG.github.filename]: {
            content: markdown
          }
        }
      };
      
      let url;
      let method;
      
      if (CONFIG.github.gistId) {
        // Update existing gist
        url = `https://api.github.com/gists/${CONFIG.github.gistId}`;
        method = 'PATCH';
      } else {
        // Create new gist
        url = 'https://api.github.com/gists';
        method = 'POST';
      }
      
      const response = await fetch(url, {
        method: method,
        headers: {
          'Authorization': `token ${CONFIG.github.token}`,
          'Content-Type': 'application/json',
          'User-Agent': 'Facebook-Stream-Manager'
        },
        body: JSON.stringify(gistData)
      });
      
      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
      }
      
      const result = await response.json();
      
      // Save the gist ID for future updates
      if (!CONFIG.github.gistId && result.id) {
        CONFIG.github.gistId = result.id;
        Logger.info(`Created new GitHub Gist: ${result.html_url}`);
      }
      
      Logger.success(`GitHub Gist updated: ${result.html_url}`);
      return result.html_url;
      
    } catch (error) {
      Logger.error(`Failed to update GitHub Gist: ${error.message}`);
      return null;
    }
  }

  // Get DASH URLs for GitHub
  static async collectDashUrls() {
    const streamsData = [];
    
    for (const item of allItems.values()) {
      if (item.dash && item.streamId) {
        streamsData.push({
          name: item.name,
          dash: item.dash,
          streamId: item.streamId,
          source: item.source,
          status: "Active"
        });
      }
    }
    
    return streamsData;
  }
}

// ================== TELEGRAM ==================
class Telegram {
  static async send(text) {
    const url = `https://api.telegram.org/bot${CONFIG.telegram.botToken}/sendMessage`;
    await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        chat_id: CONFIG.telegram.chatId,
        text,
        parse_mode: "HTML"
      })
    });
  }
}

// ================== FACEBOOK ==================
class FacebookAPI {
  // Create Facebook Live
  static async createLive(token, name) {
    const res = await fetch(
      "https://graph.facebook.com/v24.0/me/live_videos",
      {
        method: "POST",
        headers: { 
          "Content-Type": "application/json",
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
        },
        body: JSON.stringify({
          title: name,
          status: "UNPUBLISHED",
          access_token: token
        })
      }
    );
    const json = await res.json();
    if (json.error) throw new Error(json.error.message);
    return {
      id: json.id,
      rtmps: json.secure_stream_url
    };
  }

  // Get DASH after FFmpeg starts
  static async getDash(id, token) {
    const res = await fetch(
      `https://graph.facebook.com/v24.0/${id}?fields=dash_preview_url&access_token=${token}`,
      {
        headers: {
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
        }
      }
    );
    const json = await res.json();
    if (json.error) throw new Error(json.error.message);
    return json.dash_preview_url;
  }

  // Get stream preview URL (different from DASH)
  static async getStreamPreview(id, token) {
    const res = await fetch(
      `https://graph.facebook.com/v24.0/${id}?fields=stream_url&access_token=${token}`,
      {
        headers: {
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
        }
      }
    );
    const json = await res.json();
    if (json.error) throw new Error(json.error.message);
    return json.stream_url;
  }
}

// ================== FFMPEG ERROR ANALYZER ==================
class FfmpegErrorAnalyzer {
  static analyzeErrorMessage(errorMsg) {
    const error = errorMsg.toLowerCase();
    let type = "Unknown Error";
    let details = errorMsg.slice(0, 200);
    let solution = "Check logs for details";
    
    // Network/Connection Errors
    if (error.includes("connection refused") || error.includes("connection failed")) {
      type = "Connection Error";
      details = "Cannot connect to source server";
      solution = "Check if source server is online and accessible";
    }
    else if (error.includes("no route to host") || error.includes("network is unreachable")) {
      type = "Network Error";
      details = "Network route to server unavailable";
      solution = "Check network connectivity and firewall settings";
    }
    else if (error.includes("connection timed out") || error.includes("timeout")) {
      type = "Timeout Error";
      details = "Connection to source timed out";
      solution = "Server may be overloaded or network slow";
    }
    else if (error.includes("end of file") || error.includes("eof")) {
      type = "Stream Ended";
      details = "Source stream ended unexpectedly";
      solution = "Source server stopped streaming";
    }
    
    // Input/URL Errors
    else if (error.includes("invalid data found") || error.includes("invalid input")) {
      type = "Input Format Error";
      details = "Source stream format not recognized";
      solution = "Check if source URL format is correct";
    }
    else if (error.includes("server returned") || error.includes("401") || error.includes("403")) {
      type = "Authentication Error";
      details = "Source server rejected connection";
      solution = "Check credentials or access permissions";
    }
    else if (error.includes("404") || error.includes("not found")) {
      type = "URL Not Found";
      details = "Source URL does not exist";
      solution = "Verify the source URL is correct";
    }
    else if (error.includes("protocol not found")) {
      type = "Protocol Error";
      details = "Unsupported streaming protocol";
      solution = "Check if protocol (rtmp, rtsp, etc.) is supported";
    }
    
    // FFmpeg/Encoding Errors
    else if (error.includes("cannot open resource") || error.includes("failed to open")) {
      type = "Resource Error";
      details = "Cannot open source stream";
      solution = "Source may be offline or URL incorrect";
    }
    else if (error.includes("input/output error")) {
      type = "I/O Error";
      details = "Disk or network I/O error";
      solution = "Check disk space and network connection";
    }
    else if (error.includes("bitstream filter not found")) {
      type = "Codec Error";
      details = "Unsupported codec or filter";
      solution = "FFmpeg may need additional codecs";
    }
    else if (error.includes("too many packets buffered")) {
      type = "Buffer Overflow";
      details = "Too much data buffered";
      solution = "Source may be sending data too fast";
    }
    
    // Output/Destination Errors
    else if (error.includes("failed to update header") || error.includes("broken pipe")) {
      type = "Output Error";
      details = "Cannot write to Facebook RTMPS";
      solution = "Check Facebook token and permissions";
    }
    else if (error.includes("access denied") || error.includes("permission denied")) {
      type = "Permission Error";
      details = "Access denied to destination";
      solution = "Check Facebook access token";
    }
    
    return { type, details, solution };
  }
  
  static getDetailedReport(errorMsg, streamName) {
    const analysis = this.analyzeErrorMessage(errorMsg);
    return {
      title: `üî¥ FFmpeg Error: ${streamName}`,
      errorType: analysis.type,
      errorDetails: analysis.details,
      solution: analysis.solution,
      timestamp: new Date().toISOString(),
      rawError: errorMsg.slice(0, 300)
    };
  }
}

// ================== STREAM MANAGER ==================
class StreamManager {
  static startFFmpeg(item) {
    try {
      Logger.info(`Starting FFmpeg for: ${item.name}`);
      
      // Increment retry counter
      const currentRetries = streamRetries.get(item.id) || 0;
      streamRetries.set(item.id, currentRetries + 1);
      
      // FFmpeg command with User-Agent in input
      const ff = spawn("ffmpeg", [
        "-re",
        "-user_agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "-i", item.source,
        "-c", "copy",
        "-f", "flv",
        item.rtmps
      ], {
        detached: true
      });

      // Store stream info with metadata
      activeStreams.set(item.id, {
        process: ff,
        item: item,
        startTime: Date.now(),
        status: "running",
        retries: currentRetries + 1,
        lastOutput: Date.now(),
        lastError: null,
        errorCount: 0
      });

      // Monitor FFmpeg output
      ff.stdout.on("data", d => {
        const streamInfo = activeStreams.get(item.id);
        if (streamInfo) {
          streamInfo.lastOutput = Date.now();
        }
      });

      ff.stderr.on("data", d => {
        const msg = d.toString();
        const streamInfo = activeStreams.get(item.id);
        if (streamInfo) {
          streamInfo.lastOutput = Date.now();
          
          // Log all FFmpeg output for debugging
          if (msg.trim().length > 0) {
            fs.appendFileSync(`ffmpeg_${item.id}.log`, `[${new Date().toISOString()}] ${msg}`);
          }
        }
        
        // Check for errors
        if (this.isErrorMessage(msg)) {
          const errorAnalysis = FfmpegErrorAnalyzer.getDetailedReport(msg, item.name);
          streamInfo.lastError = errorAnalysis;
          streamInfo.errorCount = (streamInfo.errorCount || 0) + 1;
          
          Logger.error(`FFmpeg error [${item.name}]: ${errorAnalysis.errorType} - ${errorAnalysis.errorDetails}`);
          
          // Send detailed error to Telegram
          if (streamInfo.errorCount <= 2) { // Don't spam on repeated errors
            Telegram.send(
              `üî¥ FFmpeg Error: ${item.name}\n\n` +
              `üìõ Type: ${errorAnalysis.errorType}\n` +
              `üìã Details: ${errorAnalysis.errorDetails}\n` +
              `üõ†Ô∏è Solution: ${errorAnalysis.solution}\n` +
              `üîÑ Retry: ${streamInfo.retries}/${CONFIG.maxRetries}`
            );
          }
          
          // Individual stream failure handling
          if (streamInfo && streamInfo.retries <= CONFIG.maxRetries) {
            Logger.info(`Attempting to restart stream: ${item.name} (retry ${streamInfo.retries}/${CONFIG.maxRetries})`);
            setTimeout(() => {
              StreamManager.restartStream(item.id, errorAnalysis.errorType);
            }, 5000);
          } else {
            // Too many retries
            const errorReport = FfmpegErrorAnalyzer.getDetailedReport(`Max retries exceeded for ${item.name}. Last error: ${msg}`, item.name);
            ExceptionHandler.trigger(`FFmpeg Error in ${item.name} - ${errorReport.errorType}`);
          }
        }
      });

      ff.on("exit", (code, signal) => {
        let exitReason = "";
        if (code !== null) {
          exitReason = `Exit code: ${code}`;
        } else if (signal !== null) {
          exitReason = `Killed by signal: ${signal}`;
        }
        
        Logger.warn(`FFmpeg exited [${item.name}]: ${exitReason}`);
        
        const streamInfo = activeStreams.get(item.id);
        if (streamInfo) {
          streamInfo.status = "stopped";
          streamInfo.exitCode = code;
          streamInfo.exitSignal = signal;
          streamInfo.stopTime = Date.now();
          
          // Analyze exit reason if no error message was caught
          if (!streamInfo.lastError && exitReason) {
            const errorAnalysis = FfmpegErrorAnalyzer.getDetailedReport(
              `FFmpeg exited with ${exitReason}`, 
              item.name
            );
            streamInfo.lastError = errorAnalysis;
          }
        }
        
        // Individual stream restart logic
        if (streamInfo && streamInfo.retries <= CONFIG.maxRetries) {
          Logger.info(`Stream ${item.name} exited, attempting restart (retry ${streamInfo.retries}/${CONFIG.maxRetries})`);
          
          // Send exit notification
          if (streamInfo.lastError) {
            Telegram.send(
              `üîÑ FFmpeg Restart: ${item.name}\n\n` +
              `üìõ Previous error: ${streamInfo.lastError.errorType}\n` +
              `üîÑ Retry ${streamInfo.retries}/${CONFIG.maxRetries}`
            );
          }
          
          setTimeout(() => {
            StreamManager.restartStream(item.id, "Process Exit");
          }, 5000);
        } else {
          // Too many retries
          ExceptionHandler.trigger(`FFmpeg Exit in ${item.name} - Max retries exceeded`);
        }
      });

      ff.on("error", (err) => {
        Logger.error(`FFmpeg spawn error [${item.name}]: ${err.message}`);
        const errorAnalysis = FfmpegErrorAnalyzer.getDetailedReport(err.message, item.name);
        
        Telegram.send(
          `üö® FFmpeg Spawn Error: ${item.name}\n\n` +
          `üìõ Type: ${errorAnalysis.errorType}\n` +
          `üìã Details: ${errorAnalysis.errorDetails}\n` +
          `üõ†Ô∏è Solution: ${errorAnalysis.solution}`
        );
        
        ExceptionHandler.trigger(`FFmpeg Spawn Error in ${item.name}`);
      });

      ff.unref();
      
      return true;
    } catch (error) {
      Logger.error(`Failed to start FFmpeg for ${item.name}: ${error.message}`);
      
      const errorAnalysis = FfmpegErrorAnalyzer.getDetailedReport(error.message, item.name);
      Telegram.send(
        `üö® FFmpeg Start Failed: ${item.name}\n\n` +
        `üìõ Type: ${errorAnalysis.errorType}\n` +
        `üìã Details: ${errorAnalysis.errorDetails}\n` +
        `üõ†Ô∏è Solution: ${errorAnalysis.solution}`
      );
      
      return false;
    }
  }

  // Check if message contains error
  static isErrorMessage(msg) {
    const errorMsg = msg.toLowerCase();
    return (
      errorMsg.includes("error") ||
      errorMsg.includes("failed") ||
      errorMsg.includes("connection refused") ||
      errorMsg.includes("no route to host") ||
      errorMsg.includes("connection timed out") ||
      errorMsg.includes("invalid data found") ||
      errorMsg.includes("server returned") ||
      errorMsg.includes("input/output error") ||
      errorMsg.includes("cannot open resource") ||
      errorMsg.includes("protocol not found") ||
      errorMsg.includes("404 not found") ||
      errorMsg.includes("401 unauthorized") ||
      errorMsg.includes("403 forbidden") ||
      errorMsg.includes("end of file") ||
      errorMsg.includes("eof") ||
      errorMsg.includes("broken pipe") ||
      errorMsg.includes("access denied") ||
      errorMsg.includes("permission denied")
    );
  }

  // Restart individual stream with error reason
  static async restartStream(streamId, errorReason = "Unknown") {
    const streamInfo = activeStreams.get(streamId);
    if (!streamInfo) {
      Logger.warn(`Cannot restart stream ${streamId}: not found`);
      return;
    }

    const item = streamInfo.item;
    
    if (streamInfo.process && !streamInfo.process.killed) {
      streamInfo.process.kill('SIGTERM');
    }
    
    activeStreams.delete(streamId);
    
    try {
      Logger.info(`Creating new Facebook Live for: ${item.name} (Previous error: ${errorReason})`);
      const live = await FacebookAPI.createLive(item.token, item.name);
      item.streamId = live.id;
      item.rtmps = live.rtmps;
      
      // Wait 15 seconds before starting FFmpeg
      Logger.info(`Waiting 15 seconds before starting FFmpeg for: ${item.name}`);
      await new Promise(r => setTimeout(r, CONFIG.preStartDelay));
      
      StreamManager.startFFmpeg(item);
      
      await Telegram.send(
        `üîÑ Stream Restarted: ${item.name}\n\n` +
        `üìõ Previous error: ${errorReason}\n` +
        `üÜî New stream ID: ${item.streamId}\n` +
        `üîÑ Retry count: ${streamInfo.retries}/${CONFIG.maxRetries}`
      );
      
    } catch (error) {
      Logger.error(`Failed to recreate Facebook Live for ${item.name}: ${error.message}`);
      ExceptionHandler.trigger(`Failed to recreate stream ${item.name}: ${error.message}`);
    }
  }

  static stopAll() {
    activeStreams.forEach((info, id) => {
      if (info.process && !info.process.killed) {
        info.process.kill("SIGTERM");
      }
    });
    activeStreams.clear();
    streamRetries.clear();
  }

  // Health check for all streams with error analysis
  static async healthCheck() {
    const now = Date.now();
    const deadStreams = [];
    const healthReport = [];
    
    activeStreams.forEach((info, streamId) => {
      const item = info.item;
      
      // Check if process is dead
      if (info.process && info.process.killed) {
        Logger.warn(`Stream ${item.name} process is killed`);
        deadStreams.push(streamId);
        healthReport.push({
          name: item.name,
          status: "KILLED",
          reason: "Process was killed externally",
          uptime: Math.floor((now - info.startTime) / 1000)
        });
      }
      // Check for zombie streams (no output for 60 seconds)
      else if (info.status === "running" && now - info.lastOutput > 60000) {
        Logger.warn(`Stream ${item.name} has no output for 60+ seconds`);
        deadStreams.push(streamId);
        healthReport.push({
          name: item.name,
          status: "ZOMBIE",
          reason: "No output for 60+ seconds",
          uptime: Math.floor((now - info.startTime) / 1000),
          lastError: info.lastError
        });
      }
      // Check for repeated errors
      else if (info.errorCount > 5) {
        Logger.warn(`Stream ${item.name} has ${info.errorCount} errors`);
        healthReport.push({
          name: item.name,
          status: "ERROR_PRONE",
          reason: `Has ${info.errorCount} errors`,
          uptime: Math.floor((now - info.startTime) / 1000),
          lastError: info.lastError
        });
      }
    });
    
    // Send health report if there are issues
    if (healthReport.length > 0) {
      let report = `ü©∫ Health Check Report\n\n`;
      healthReport.forEach(hr => {
        report += `üì∫ ${hr.name}\n`;
        report += `üìä Status: ${hr.status}\n`;
        report += `‚è±Ô∏è Uptime: ${hr.uptime}s\n`;
        report += `üìõ Reason: ${hr.reason}\n`;
        if (hr.lastError) {
          report += `üîç Last Error: ${hr.lastError.errorType}\n`;
        }
        report += `\n`;
      });
      
      await Telegram.send(report);
    }
    
    // Restart dead streams
    for (const streamId of deadStreams) {
      const info = activeStreams.get(streamId);
      if (info && info.retries <= CONFIG.maxRetries) {
        Logger.info(`Health check: restarting dead stream ${info.item.name}`);
        await StreamManager.restartStream(streamId, "Health Check Failed");
      }
    }
    
    return deadStreams.length;
  }

  // Check if all FFmpeg processes are running
  static areAllStreamsRunning() {
    return Array.from(allItems.values()).every(item => {
      const streamInfo = activeStreams.get(item.id);
      return streamInfo && streamInfo.status === "running";
    });
  }

  // Wait for all streams to be running
  static async waitForAllStreams(timeout = 120000) {
    const start = Date.now();
    const checkInterval = 2000; // Check every 2 seconds
    
    while (Date.now() - start < timeout) {
      if (this.areAllStreamsRunning()) {
        Logger.success("All streams are running!");
        return true;
      }
      
      // Count running streams and show status
      const runningCount = Array.from(allItems.values()).filter(item => {
        const streamInfo = activeStreams.get(item.id);
        return streamInfo && streamInfo.status === "running";
      }).length;
      
      const errorStreams = Array.from(activeStreams.values())
        .filter(info => info.lastError)
        .map(info => `${info.item.name} (${info.lastError.errorType})`);
      
      if (errorStreams.length > 0) {
        Logger.info(`Waiting for streams: ${runningCount}/${allItems.size} running. Errors: ${errorStreams.join(', ')}`);
      } else {
        Logger.info(`Waiting for streams: ${runningCount}/${allItems.size} running`);
      }
      
      await new Promise(r => setTimeout(r, checkInterval));
    }
    
    // If timeout, report which streams failed
    const failedStreams = Array.from(allItems.values())
      .filter(item => {
        const streamInfo = activeStreams.get(item.id);
        return !streamInfo || streamInfo.status !== "running";
      })
      .map(item => item.name);
    
    Logger.warn(`Timeout waiting for streams. Failed: ${failedStreams.join(', ')}`);
    return false;
  }
}

// ================== EXCEPTION HANDLER ==================
class ExceptionHandler {
  static async trigger(reason) {
    if (isRestarting) return;
    isRestarting = true;

    Logger.warn(`Exception: ${reason}`);
    await Telegram.send(`‚ö†Ô∏è System Exception\n${reason}\n‚è≥ Full restart in 2 minutes`);

    setTimeout(async () => {
      await Main.restart();
      isRestarting = false;
    }, CONFIG.restartDelay);
  }
}

// ================== API CHANGE DETECTOR ==================
class ApiChangeDetector {
  static createDataHash(data) {
    const itemsString = data.map(item => 
      `${item.token}|${item.name}|${item.source}|${item.img}`
    ).sort().join('||');
    
    return Buffer.from(itemsString).toString('base64');
  }

  static async checkForChanges() {
    try {
      Logger.info("Checking API for changes...");
      
      const res = await fetch(CONFIG.apiUrl, {
        headers: {
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
        }
      });
      const json = await res.json();
      
      const newHash = this.createDataHash(json.data);
      
      if (apiDataHash === "") {
        apiDataHash = newHash;
        Logger.info("Initial API data hash stored");
        return false;
      }
      
      if (newHash !== apiDataHash) {
        Logger.info(`API data changed! Old hash: ${apiDataHash.slice(0, 20)}..., New hash: ${newHash.slice(0, 20)}...`);
        
        const oldCount = allItems.size;
        const newCount = json.data.length;
        await Telegram.send(
          `üîÑ API Changes Detected!\n\n` +
          `üìä Previous streams: ${oldCount}\n` +
          `üìä New streams: ${newCount}\n` +
          `‚è≥ Restarting in 2 minutes...`
        );
        
        apiDataHash = newHash;
        ExceptionHandler.trigger("API data changed");
        return true;
      }
      
      Logger.info("No changes in API data");
      return false;
      
    } catch (error) {
      Logger.error(`Error checking API changes: ${error.message}`);
      return false;
    }
  }
}

// ================== MAIN ==================
class Main {
  // Fetch data from API
  static async fetchItems() {
    const res = await fetch(CONFIG.apiUrl, {
      headers: {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
      }
    });
    const json = await res.json();

    const map = new Map();
    json.data.forEach((it, i) => {
      map.set(`item_${i}`, {
        id: `item_${i}`,
        token: it.token,
        name: it.name,
        source: it.source,
        img: it.img
      });
    });
    
    if (apiDataHash === "") {
      apiDataHash = ApiChangeDetector.createDataHash(json.data);
    }
    
    streamRetries.clear();
    
    return map;
  }

  // Full startup
  static async start() {
    try {
      Logger.info("Fetching items from API...");
      allItems = await this.fetchItems();

      Logger.info(`Creating Facebook Live for ${allItems.size} streams...`);
      
      // 1Ô∏è‚É£ Create Facebook Live streams
      for (const item of allItems.values()) {
        try {
          const live = await FacebookAPI.createLive(item.token, item.name);
          item.streamId = live.id;
          item.rtmps = live.rtmps;
          Logger.info(`Created Facebook Live for: ${item.name} (ID: ${item.streamId})`);
        } catch (error) {
          Logger.error(`Failed to create Facebook Live for ${item.name}: ${error.message}`);
          item.failed = true;
          
          // Send error to Telegram
          await Telegram.send(
            `‚ùå Facebook Live Creation Failed\n\n` +
            `üìõ Stream: ${item.name}\n` +
            `üìã Error: ${error.message}\n` +
            `üîó Source: ${item.source}`
          );
        }
      }

      // 2Ô∏è‚É£ Wait 15 seconds before starting FFmpeg
      Logger.info(`Waiting ${CONFIG.preStartDelay/1000} seconds before starting FFmpeg...`);
      await new Promise(r => setTimeout(r, CONFIG.preStartDelay));

      // 3Ô∏è‚É£ Start FFmpeg with delays between starts
      Logger.info("Starting FFmpeg processes with User-Agent...");
      let ffmpegStarted = 0;
      
      for (const item of allItems.values()) {
        if (!item.failed) {
          if (ffmpegStarted > 0) {
            // Delay between FFmpeg starts to avoid overwhelming the system
            await new Promise(r => setTimeout(r, CONFIG.ffmpegStartDelay));
          }
          
          StreamManager.startFFmpeg(item);
          ffmpegStarted++;
        }
      }

      // 4Ô∏è‚É£ Wait for ALL streams to be running
      Logger.info("Waiting for all FFmpeg processes to start...");
      const allRunning = await StreamManager.waitForAllStreams();
      
      if (!allRunning) {
        throw new Error("Failed to start all streams within timeout");
      }

      // 5Ô∏è‚É£ Get DASH URLs (MPD) for all successful streams
      Logger.info("All streams running, fetching DASH URLs...");
      let report = `üìä STREAM REPORT\n\n`;
      let successCount = 0;
      const streamsForGithub = [];
      
      for (const item of allItems.values()) {
        if (!item.failed) {
          try {
            // Get DASH URL (MPD format)
            item.dash = await FacebookAPI.getDash(item.streamId, item.token);
            
            // Also get stream preview URL if needed
            try {
              item.previewUrl = await FacebookAPI.getStreamPreview(item.streamId, item.token);
            } catch (previewError) {
              Logger.warn(`Could not get preview URL for ${item.name}: ${previewError.message}`);
            }
            
            report += `‚úÖ ${item.name}\n`;
            report += `üîó DASH (MPD): ${item.dash}\n`;
            if (item.previewUrl) {
              report += `üì∫ Preview: ${item.previewUrl}\n`;
            }
            report += `üÜî Facebook ID: ${item.streamId}\n\n`;
            
            successCount++;
            
            // Add to GitHub data
            streamsForGithub.push({
              name: item.name,
              dash: item.dash,
              streamId: item.streamId,
              source: item.source,
              status: "Active",
              previewUrl: item.previewUrl || "N/A"
            });
            
          } catch (error) {
            report += `‚ö†Ô∏è ${item.name} - Failed to get DASH: ${error.message}\n\n`;
          }
        } else {
          report += `‚ùå ${item.name} - Failed to create Facebook Live\n\n`;
        }
      }

      report += `üìà Total: ${successCount}/${allItems.size} streams running`;
      
      // 6Ô∏è‚É£ Send Telegram report
      await Telegram.send(report);
      Logger.success(`All streams initialized: ${successCount}/${allItems.size} successful`);

      // 7Ô∏è‚É£ Update GitHub Gist with DASH URLs
      if (streamsForGithub.length > 0) {
        Logger.info("Updating GitHub Gist with stream URLs...");
        const gistUrl = await GithubGistManager.updateGist(streamsForGithub);
        
        if (gistUrl) {
          await Telegram.send(`üìù GitHub Gist updated: ${gistUrl}`);
          Logger.success(`GitHub Gist updated successfully`);
        }
      }

    } catch (error) {
      Logger.error(`Startup error: ${error.message}`);
      throw error;
    }
  }

  static async restart() {
    Logger.warn("Restarting system...");
    StreamManager.stopAll();
    await this.start();
  }
}

// ================== PERIODIC CHECKS ==================

// üìä Status report every 5 minutes
setInterval(async () => {
  if (!isRestarting) {
    const uptime = Math.floor((Date.now() - startTime) / 60000);
    const activeCount = Array.from(activeStreams.values())
      .filter(info => info.status === "running").length;
    
    // Get error statistics
    const errorStreams = Array.from(activeStreams.values())
      .filter(info => info.lastError)
      .map(info => info.item.name);
    
    let report = `üì° Status Report\n\n` +
      `‚è±Ô∏è Uptime: ${uptime} minutes\n` +
      `üìä Total streams: ${allItems.size}\n` +
      `üü¢ Active streams: ${activeCount}\n` +
      `üî¥ Inactive streams: ${allItems.size - activeCount}\n`;
    
    if (errorStreams.length > 0) {
      report += `‚ö†Ô∏è Streams with errors: ${errorStreams.length}\n`;
    }
    
    report += `üîÑ Last check: ${new Date().toLocaleTimeString()}`;
    
    await Telegram.send(report);
    
    // Update GitHub Gist periodically
    const streamsData = await GithubGistManager.collectDashUrls();
    if (streamsData.length > 0) {
      await GithubGistManager.updateGist(streamsData);
    }
  }
}, CONFIG.reportInterval);

// üîç API change check every minute
setInterval
